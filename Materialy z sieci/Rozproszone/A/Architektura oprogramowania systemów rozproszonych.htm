<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta http-equiv="Creation-date" content="18 sty 2000 10:19 GMT">
<meta http-equiv="Reply-to" content="para@prz.rzeszow.pl">
<meta name="Author" content="Pawe³ Dymora &amp; Miros³aw Mazurek">
<meta name="description" content="Prace zaliczeniowe studentów">
<meta name="Keywords" content="organizacja procesow obliczeniowych,prace zliczeniowe,
corba, java, inca, systemy rozproszone, Architektura oprogramowania">
<title>Architektura oprogramowania systemów rozproszonych</title>
</head>

<body background="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/zerojeden.jpg">

<font face="Times New Roman"><p>Pawe³ Gontarz</p>
<p>Maciej Lasko </p>
</font><font face="Arial">
<p>4FDS - systemy i sieci komputerowe</p>

<p>POLITECHNIKA RZESZOWSKA</p>
</font><b><font face="Arial" size="2">
</font><font face="Verdana" size="2"><p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</font></b><font face="Arial" size="6"><p align="CENTER">Architektura oprogramowania systemów rozproszonych</p>
</font><b><font face="Verdana" size="2"><p>&nbsp;</p>
</font><font face="Arial"><p>Streszczenie</p>
</font><font color="#000000" size="2"><p align="JUSTIFY"></p></font></b><font color="#000000" size="2"></font><dir><font color="#000000" size="2"><b>
</b></font><dir><font color="#000000" size="2"><b>
</b></font><dir><font color="#000000" size="2"><b>

</b></font><font face="Times New Roman" size="2"><p align="JUSTIFY">Rosn±ce
 zapotrzebowanie systemów, które ³±czy³yby w jedn± ca³o¶æ nowe elementy,
 inspiruje rozwój architektury w kierunku rozdzielania sk³adników. 
Autorzy opisuj± dwie implementacje takiej architektury i dwie 
przyk³adowe aplikacje, jedna opierana na produkcie Java RMI i druga 
u¿ywaj±ca Corba-based. Praca w do¶æ czytelny sposób zaznajamia nas z 
problemami oprogramowania systemów rozproszonych. Na¶wietlone zosta³y 
wszelkiego rodzaju b³êdy i usterki z jakimi mo¿emy siê tutaj spotkaæ.</p></font></dir><font face="Times New Roman" size="2">

</font>

</dir></dir>
<b><font face="Arial" size="3">1. Wstêp<br></font></b><font face="Arial" size="3"></font><dir><font face="Arial" size="3"><b>
</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Wiêkszo¶æ
 przedsiêbiorstw ma du¿e zapotrzebowanie na programowe systemy 
wspieraj±ce ich ró¿norodne przedsiêwziêcia. Miêdzynarodowy Instytut Norm
 Technicznych szacuje, ¿e oko³o 85 procent instalowanego oprogramowania 
przypada w wiêkszo¶ci na du¿e organizacje, które z niego korzystaj±. 
Mimo to jednak wiêkszo¶æ aplikacji stosuje siê do monolitycznych i 
pojedynczych zastosowañ, które s± kosztowne w budowie i </font>m<font face="Times New Roman">a³o
 odporne na b³êdy. W przemy¶le gdzie systemy musz± byæ rozmieszczone 
szybko wed³ug okre¶lonych zasad, upraszcza siê i automatyzuje syntezê 
oprogramowania stosuj±c do tego wielokrotnie wykorzystywane, wypróbowane
 i niezbêdne sk³adniki. St±d te¿ ostatnie</font> <font face="Times New Roman">zainteresowanie
 sk³adowymi oprogramowania od strony in¿ynierii po¶ród badaczy i 
praktyków. Nasze prace prowadzone w kierunku badania architektury, 
technologii i produktów przeznaczonych do budowy oprogramowania 
systemowego na du¿± skalê , szczególnie wyso</font>k<font face="Times New Roman">o
 interakcyjnego, rozdzielaj± aplikacje na takie jakie s± potrzebne dla 
komunikuj±cych siê klientów. W rozwoju architektury oprogramowania 
systemów rozproszonych starali¶my siê stworzyæ architekturê z prostymi 
mechanizmami dla tworzonych po³±czeñ miêdzy s</font>k<font face="Times New Roman">³adnikami.
 Wierzymy, ¿e w przysz³ych, otwartych i elastycznych systemach bêdziemy 
siê opierali na lu¼no powi±zanych konfiguracjach , rozdzielanych 
sk³adników owych systemów, które mimo to bêd± skalowalne, zwiêz³e i w 
pe³ni kierowalne. Powinna tutaj zaistn</font>i<font face="Times New Roman">eæ
 mo¿liwo¶æ rozk³adania istniej±cych systemów na spójne sk³adniki, które 
mog³y by byæ po³±czone z innymi, nowymi sk³adnikami i u¿yte w innych 
zastosowaniach.</font></p><font face="Times New Roman">
<p align="JUSTIFY">Dla zachowania kompatybilno¶ci, architektura 
oprogramowania powinna byæ realizowana przy pomocy dostêpnych 
technologii i produktów.</p>
</font><b><font face="Arial"></font></b></dir><b><font face="Arial">2. Definiowanie architektury oprogramowania
</font></b><dir><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Opieraj±c
 siê na ró¿nych ¼ród³ach stwierdzamy, ¿e badania prowadzone nad budow± 
oprogramowania nie wy³oni³y jako takiej definicji architektury 
oprogramowania. Wiêkszo¶æ definicji ³±czy w sobie sk³adniki, ³±czniki 
oraz kila atrybutów powi±zanych racjonaln± podstaw± i w³asno¶ciami. 
Definicja architektury jêzyków takich jak RAPIDE formalnie definiuje 
architektoniczne powi±zania sk³adników pod wzglêdem interfejsu jak i 
innych komponen</font>t<font face="Times New Roman">ów. Wiêkszo¶æ 
definicji istnieje dla "sk³adników" jako ca³o¶ci , nie odró¿niaj±c przy 
tym sk³adników bêd±cych obiektami, programami itp. Architektura jest 
teoretycznym modelem definiowania i rozwijania sk³adników systemowych 
oraz sposobu ich interpretacji</font>,<font face="Times New Roman"> przez co odró¿niamy to od infrastruktury wprowadzaj±cej w ¿ycie pojêciowy model. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">	Infrastruktura 
oprogramowania wywodz±ca siê od infrastruktur systemów i produktów musi 
stosowaæ siê do norm architektonicznych. Np. prosta architektura typu 
klient-server ³±czy w sobie interfejs u¿ytkownika i administratora bazy 
danych. Specyficzne produkty ³±cz± X Window i Oracle DBMS. 
Infrastruktura sk³adaj±ca siê z tych produktów i sk³adników wymaga 
po³±czenia ich ze sob± w jedn± ca³o¶æ. Architektura oprogramowania musi </font>b<font face="Times New Roman">yæ
 wykonywana u¿ywaj±c dostêpnych technologii i produktów, które 
wspó³dzia³aj± ze sob±. Wybranie jednak najnowocze¶niejszych technologii i
 produktów nie gwarantuje spójno¶ci architektury. Z drugiej jednak 
strony, definiuj±c spójn± architekturê nie bacz±c </font>n<font face="Times New Roman">a
 istniej±ce technologie mo¿na doprowadziæ do z³ego dopasowania miêdzy 
teoretycznym modelem architektury a przedmiotem modelu, tkwi±cego w 
istniej±cych produktach. To z³e dopasowanie z kolei prowadzi do braku 
akceptacji d³u¿szego rozwoju poniewa¿ nowators</font>k<font face="Times New Roman">ie
 sk³adniki musz± zostaæ stworzone zanim zostanie skonstruowana zawarto¶æ
 aplikacji. Skupiamy siê dlatego na architekturze, takiej, która 
pozwala³aby wprowadzaæ w ¿ycie g³ówne obiekty architektury - Corba, 
DCOM, Java RMI.&nbsp;</font></p><font face="Times New Roman">
</font></dir><b><font face="Arial"> 3. INCA (Architektura oprogramowania systemów rozproszonych)
</font></b><font face="Arial"></font><dir><font face="Arial"><b>


</b></font><font face="Times New Roman"><p align="JUSTIFY">Architektura 
oprogramowania systemów rozproszonych buduje mechanizmy po³±czeñ miêdzy 
sk³adnikami, które nastêpnie wprowadza siê i stosuje w architekturze. 
Mimo, ¿e to ogranicza w pewien sposób spokojne przygotowanie sk³adników,
 to jednak praktycznie te wszystkie niedogodno¶ci tak naprawdê u³atwiaj±
 trudny proces komponowania sk³adników w jedn± ca³o¶æ wed³ug okre¶lonych
 zasad narzuconych przez wzglêdy architektoniczne. Nie definiuje siê 
jako tako niezale¿nych mechanizmów umo¿liwiaj±cych uniwersalne ³±czenie 
sk³adników. </p>
<p align="JUSTIFY">	INCA jako pojêciowy model definiuje cztery wiêksze elementy:</p></font></dir><font face="Times New Roman">



</font><ul><font face="Times New Roman">
</font><dir><font face="Times New Roman">
</font><dir><font face="Times New Roman">
<li>sk³adniki </li>
</font><li>zdalne zdarzenia </li>
<font face="Times New Roman"><li>czas wykonania konfiguracji narzêdzi w odniesieniu do sk³adników </li>
<li>wzajemne oddzia³ywanie zarz±dców</li></font></dir></dir></ul><font face="Times New Roman">

</font><b><font face="Arial"><p align="JUSTIFY">Sk³adniki </p></font></b><font face="Arial"></font><dir><font face="Arial"><b>


</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Sk³adniki
 s± wa¿n± spraw± dla podstawowej czê¶ci architektury. S± one 
gruboziarniste, odbudowuj± dzia³anie f-cji podobnie jak lista 
telekomunikacyjnych us³ug dla dostêpnych klientów. Konwencjonalny 
sk³adnik gruboziarnisty przeznaczony do ponownego u¿ycia , j</font>e<font face="Times New Roman">st to czêsto za ma³o do praktycznego u¿ycia od czasu zwiêkszonych wymagañ aplikacji.</font></p><font face="Times New Roman">
<p align="JUSTIFY">Wchodz±ce w sk³ad INCA sk³adniki sk³adaj± siê z jednej albo wielu czê¶ci:</p></font></dir><font face="Times New Roman">


</font><ul><font face="Times New Roman">
</font><dir><font face="Times New Roman"></font><dir><font face="Times New Roman">
<li>nieodzowny serwer, który wykonuje takie funkcje jak np. zabezpieczanie d³ugich odcinków </li>
</font><li><p align="JUSTIFY">fu<font face="Times New Roman">nkcjonalny interfejs u¿ytkownika pozwalaj±cy na wspó³dzia³anie z business function </font></p></li><font face="Times New Roman">
<li><p align="JUSTIFY">wewnêtrzny dostêp do us³ug bazy danych, który hermetyzuje dostêp do niej</p></li></font></dir></dir></ul><dir><font face="Times New Roman">
</font></dir><font face="Times New Roman">
</font><p align="JUSTIFY"></p>

<p align="JUSTIFY"></p>
<font size="2"></font><p align="CENTER"><font size="2">
<img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys1.jpg" height="364" width="601">
<br>
</font><i><font face="Arial" size="2">Rys1) Wielofunkcyjne sk³adniki w INCA</font></i></p><i><font face="Arial" size="2">
</font></i><b><font size="2"><p align="JUSTIFY">&nbsp;</p></font></b><font size="2"></font><dir><font size="2"><b>

</b></font><dir><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Pierwszy
 rysunek obrazuje abstrakcyjn± konfiguracjê sk³adników. W pe³ni 
programowalne pojedyncze sk³adniki stosuje siê w trzeciej warstwie 
modelu client-server. Sk³adniki s± lu¼no powi±zane ze zdarzeniami 
wywo³añ wiêkszo¶ci sk³adników serwera. W tej pozio</font>m<font face="Times New Roman">ej
 kompozycji mo¿emy doszukaæ siê logicznych buisness function w 
przeciwieñstwie do pionowych kompozycji opieranych na fizycznej 
funkcjonalno¶ci. Taka infrastruktura dostarcza hierarchicznej spójno¶ci 
sk³adników systemu, u³atwiaj±c kompozycjê aplikacji z </font>i<font face="Times New Roman">stniej±cych sk³adników z minimalnym wp³ywem na inne sk³adniki. </font></p></dir><font face="Times New Roman">
</font></dir><font face="Times New Roman">
</font><b></b><dir><b><font face="Arial"><p align="JUSTIFY">Zdalne zdarzenia</p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Servery nale¿± do odmiennych sk³adników komunikuj±cych siê na wypadek zawiadomienia.</font></p>
<font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Sk³adniki
 serwera mog± byæ informowane o charakterystycznych zdarzeniach 
generowanych przez inne sk³adniki. Zdarzenie generowane przez sk³adniki 
serwera s± ¼ród³em; zdarzeñ odbieranych przez nas³uchuj±cych. Od kiedy 
s³uchacz mo¿e byæ odleg³y , potrzebujemy w takim wypadku niezawodnych 
mechanizmów transferu zdarzeñ miêdzy ¼ród³em a s³uchaczem p</font><font>o</font><font face="Times New Roman">nad sieci±. </font><font color="#000000" face="Times New Roman">Jedno
 z rozwi±zañ zak³ada³oby stworzenie centralnego serwera informacji do 
którego ¼ród³o przekazywa³oby te zdarzenia. Serwer informacji natomiast 
wysy³a³ by te zdarzenia do nas³uchuj±cych. To wszystko nie bêdzie jednak
 dzia³a³o dla rozdzielanych sk³adników. Tym niemniej, komunikacja od i 
do serwera i wykonanie ³adowania tworz± w±skie gard³a i pojedyncze 
uszkodzenia. Dla unikniêcia tych zatorów INCA decentralizuje kontrolê 
przep³ywu zdarzeñ. Do u³atwienia po³±czeñ miêdzy sk³adnikami , definiuje</font><font color="#000000">m</font><font color="#000000" face="Times New Roman">y
 ogóln± metodê do nadaj±cych siê sk³adników, i generujemy klasê 
sk³adników od których wywodz± siê wszystkie sk³adniki okre¶laj±ce 
zdarzenia.&nbsp;</font></p><font color="#000000" face="Times New Roman">
<p align="JUSTIFY">Rysunek 2 obrazuje zdarzenia ¼ród³a (Serwer A) z list± s³uchaczy zawieraj±c± uprawnienia dla trzech komponentów:</p>
</font><font color="#000000"><p align="JUSTIFY">serwera B, C i D. </p></font></dir><font color="#000000">

</font><p align="CENTER"><font color="#000000"><br>
</font><font color="#000000" size="2"><br>
<img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys2.jpg" height="222" width="324"><br>
<br>
</font><i><font color="#000000" face="Arial" size="2">Rys2) Wielofunkcyjne sk³adniki w INCA Odleg³e sk³adniki w INCA</font></i></p><i><font color="#000000" face="Arial" size="2">
</font></i><font color="#000000" size="2"><p align="JUSTIFY">&nbsp;</p>
</font><b><font color="#000000" face="Arial"><p align="JUSTIFY">Czas wykonania konfiguracji</p></font></b><font color="#000000" face="Arial"></font><dir><font color="#000000" face="Arial"><b>

</b></font><font face="Times New Roman"><p align="JUSTIFY">Architektura 
ustala po³±czenia sk³adników bardziej w czasie wykonania ni¿ w czasie 
kompilacji lub projektowania ( podobnie jak w modelu JavaBeans ). Jeden 
sk³adnik przy³±cza siê do innych po czym jeden z nich albo obaj maj± 
rozmieszczaæ i wytwarzaæ egzemplarze.</p>
<p align="JUSTIFY">Taka dynamiczna konfiguracja pozwala nam przystosowaæ aplikacje podczas gdy one przyczyniaj± siê do ich</p></font></dir><font face="Times New Roman">


<ul>
<dir>
<li>dostêpno¶ci </li>
<li><p align="JUSTIFY">niezawodno¶ci, od tego czasu rozbity lub wadliwy sk³adnik mo¿e byæ zast±piony w aplikacji </p></li>
<li><p align="JUSTIFY">osi±gniêæ, od tego czasu po³±czenia mog± byæ 
rekonfigurowane jako rezultat zmian obci±¿eñ procesora lub obci±¿eñ 
sieci miêdzy sk³adnikami</p></li></dir></ul>
</font></dir><dir><font face="Times New Roman">

</font><p align="JUSTIFY"><font face="Times New Roman">Architektura 
definiuje narzêdzia konfiguracji sk³adników, które pozwalaj± ustaliæ 
administratorowi oraz rejestrowaæ zdarzenia miêdzy obiektami serwera. 
Narzêdzie to ³±czy zdarzenia ¼ród³a ze s³uchaczami przez powi±zanie 
dynamicznych skoków do ¼ród³a serwera. INCA pozwala te¿ na 
rekonfiguracjê zwi±zku ¼ród³o - s³uchacz w serwerze konfiguracji plików,
 które serwer czyta w czasie uruchomienia. Od czasu braku 
scentralizowania baz danych, po³±czenie ma miejsce w czasie wykonywania 
konfiguracji narzêd</font><font>z</font><font face="Times New Roman">i. Narzêdzie jednak nie bierze udzia³u w czasie transmisji . </font></p><font face="Times New Roman">
</font><b><font></font></b><font></font><p align="JUSTIFY"><font><b>Rysunek 3</b></font><font face="Times New Roman">
 pokazuje konfiguracjê narzêdzi w interfejsie u¿ytkownika. Do ustalenia 
nowego zwi±zku, administrator wyszczególnia nazwy sk³adników, nazwy 
instancji i lokalizacje dla zarówno s³uchaczy jak i ¼ród³a. ¬ród³o 
³aduje wtedy w³a¶ciw± klasê zastêpcz± i wytwarza obiekt zastêpczy ( 
stosowane podczas dynamicznego ³adowania klas Javy ). Nazwa klasy 
zastêpczej jest kszta³towana przez ³±czenie nazw z przyrostkiem "Proxy" 
(np. LoggerProxy). Odleg³e </font><font>s</font><font face="Times New Roman">k³adniki nie potrzebuj± byæ aktywowane kiedy kreowane jest zastêpstwo (wymaga to silnego po³±czenia w czasie wykonywania). </font></p><font face="Times New Roman">
</font><font color="#000000" size="2"><p align="JUSTIFY">&nbsp;</p>
</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys3.jpg" height="450" width="480"><font color="#000000" size="2"><br>
<br>
</font><i><font color="#000000" face="Arial" size="2">Rys3) Konfiguracja interfejsu narzêdziowego</font></i></p><i><font color="#000000" face="Arial" size="2">
</font></i><b><font color="#000000" face="Arial"><p align="JUSTIFY">
</p></font></b></dir><b><font color="#000000" face="Arial">
Interakcyjny zarz±dca 	 <p></p>
</font></b><font face="Times New Roman"></font><dir><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Dla
 poziomej kompozycji sk³adników , za pomoc± dostêpnych elementów 
interfejsu u¿ytkownika, g³ówne elementy architektoniczne musz± zespalaæ 
wiele klientów w pojedyncz± aplikacjê. INCA definiuje interakcyjnego 
zarz±dcê, który pozwala sprawowaæ kontrolê nad</font><font> </font><font face="Times New Roman">przebiegiem
 aplikacji. To tak¿e dotyczy jasnego celu serwera informacji, który 
obs³uguje interfejs u¿ytkownika, akceptuje informacje kontrolne od 
sk³adników serwera i odwo³uje siê do sk³adników klienta. Interakcyjny 
zarz±dca tworzy globalny i unikalny ide</font><font>n</font><font face="Times New Roman">tyfikator
 sesji, inicjalizuje pierwszy sk³adnik, dostarcza zdalne us³ugi dla 
serwera, które s³u¿± do pó¼niejszego uruchomienia sk³adników. Zarz±dca 
ten równie¿ wykorzystuje i obs³uguje przestoje sk³adników. Ka¿da stacja 
robocza dzia³aj±ca na aplikacjach o</font><font>p</font><font face="Times New Roman">artych o INCA chce mieæ jedn± instancjê interakcyjnego zarz±dcy.&nbsp; </font></p></dir><font face="Times New Roman">


</font><b><font face="Arial"><p>4. Prototyp aplikacji</p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Tworzymy
 Service Provisioning Scenario (scenariusz ¶wiadczenia us³ug ) dla 
zbadania architektury. Ten dobrze znany scenariusz telekomunikacyjny 
symuluje sesjê miêdzy k</font><font>lientem i phone rep.</font><font color="#ff0000"> </font><font face="Times New Roman">Ekran
 powitalny rezerwuje miejsce na numer telefonu klienta i przycisk 
pozwalaj±cy odszukaæ pewne dane klienta. Zak³adka z list± dostêpnych 
us³ug pozwala klientowi wybraæ now± us³ugê tak± jak np., LongDistance 
(patrz rys. 3). Na zakoñczenie ta interakcja prowadzi do utworzenia 
nowego obiektu obs³ugi ¿±dania. Kiedy by³a tworzona ta nowa us³uga, 
serwer zabezpieczaj±cy aktualizowa³ dane klienta z nowym objektem 
us³ugowym i powiadamia³ phone rep</font><font color="#ff0000"> </font><font face="Times New Roman">(i ewentualnie u¿ytkownika) przez e-mail. 	Identyfikujemy piêæ sk³adników do us³ug klienta. &nbsp;</font></p></dir><font face="Times New Roman">


</font><ul><font face="Times New Roman">
</font><dir><font face="Times New Roman">
</font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Przywitanie.
 Ten sk³adnik dostarcza interfejs u¿ytkownika przez WelcomeApllet, który
 akceptuje podstawowy numer telefonu klienta i przekazuje go do 
WelcomeServer. WelcomeServer wywo³uje wtedy CustomerArri</font><font>valEvent. </font></p></li><font>
</font><font face="Times New Roman"><li><p align="JUSTIFY">Klient . W 
momencie kiedy przyjmowane przez CustomerArrivalEvent, ten sk³adnik 
tworzy aktualn± bazê danych do odzyskiwania szczegó³owych informacji 
klienta. Teraz zwraca siê z pro¶b± do AppletMnager o uruchomienie 
CustomerApplet wy¶wietlajacego te dane. Na pro¶bê klienta 
,CustomerApplets zawiadamia serwer, którego klient potrzebuje do 
podgl±dniêcia ServiceOptions. Ten serwer generuje 
ServiceOptionsRequestEvent. </p></li>
</font><font <li=""><p align="JUSTIFY"></p></font><p align="JUSTIFY"><font <li="">ServiceOptions. Po otrzymaniu ServiceOptionsRequestEvent ServiceOptio</font><font face="Times New Roman">nsServer
 prosi o pokazanie opcji us³ug dostêpnych dla klienta, takich jak np. 
LongDistance lub CallWaiting (obs³ugiwanie po³±czeñ). Kiedy u¿ytkownik 
wybiera opcje us³ugi, interfejs u¿ytkownika wywo³uje serwer z opcjami 
generuj±cymi ServiceOptionSelectedEv</font><font>ent 
</font><font face="Times New Roman"></font></p><li><p align="JUSTIFY"><font face="Times New Roman">LongDistance.
 Po otrzymaniu ServiceOptionSelectedEvent z wyborem "LongDistance" 
,serwer generuje listê no¶ników i pyta stosowny AppletMenager o 
uruchomienie LongDistanceApplet, który wy¶wietli t± listê. Kiedy 
u¿ytkownik wybierze no¶nik LongDistanceApplet zawiadomi serwer 
generuj±cy LDSelectedEvent. LongDistanceServer wtedy dodaje nowe ¿±dania
 obs³ugi danych klienta przez Customer serwer. </font></p></li><font face="Times New Roman">
<li><p align="JUSTIFY">LDHandler. Kiedy otrzymywany jest 
LDSelectedEvent, serwer ³±czy odpowiednie no¶niki. Po otrzymaniu 
potwierdzenia po³±czenia wysy³any jest e-mail do phone rep i klienta 
(je¿eli klient ma e-mail) po czym zostaj± zaktualizowane dane klienta 
przeznaczone do pokazania aby ServiceRequest zosta³o zamkniête i dodane 
do nowych ActiveService objektów. </p></li></font></dir></ul><font face="Times New Roman">

</font><font color="#000000"><p align="JUSTIFY">&nbsp;</p></font><dir><font color="#000000">

</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys4.jpg" height="415" width="584"></p>
<i><font color="#000000" face="Arial" size="2"><p align="CENTER">Rys4) Prototyp aplikacji: czê¶ci sk³adowe odbiorcy</p>
</font></i><font color="#000000" size="2"><p align="JUSTIFY">&nbsp;</p>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">To
 wszystko obrazuje rysunek 4. My te¿ definiujemy ogólny rejestrator 
sk³adników , który oczekuje na sygna³ od obiektu serwera o zaj¶ciu 
jakiego¶ zdarzenia po czym umieszcza go w bazie danych. Taki sk³adnik 
mo¿e byæ dynamicznie przy³±czany do innych komponentów rejestruj±cych 
dzia³ania, bez oddzia³ywania na inne sk³adniki w systemie.</font><font color="#000000">&nbsp;</font></p></dir><font color="#000000">

</font><b><font face="Arial"><p>5. Dwie implementacje INCA</p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"><p align="JUSTIFY">My 
implementujemy pojêciowy model INCA w oparciu o Java RMI i Corba. 
Szkielet modelu redukuje w wiêkszo¶ci trudno¶ci zwi±zane z implementacj±
 INCA rozdzielaj±c± obiekty struktury. </p></font></dir><font face="Times New Roman">
<dir <="" font=""><b><font color="#000000" face="Arial"><p>Definicja sk³adników programu</p></font></b><font color="#000000" face="Arial"></font><dir><font color="#000000" face="Arial"><b>

</b></font><font face="Times New Roman"><p align="JUSTIFY">W ostatniej 
pracy Eric Evans i Daniel Rogers, Java applets oddzia³uje wzajemnie z 
odleg³ymi serwerami za po¶rednictwem Corba. Autorzy zauwa¿aj± ¿e 
stosowanie Java applet pomaga rozwi±zywaæ niektóre problemy zwi±zane z 
klientem. Evans i Rogers stosuj± te¿ serwery Corba do adresowania 
platform i jêzyków niezale¿nych </p>
<p align="JUSTIFY">Nasze pojêcie o strukturalnych elementach opisuje jasno migracjê implementacji INCA wzglêdem ró¿nych struktur. </p>
</font><p align="JUSTIFY"><font face="Times New Roman">	Robert Allen i 
David Garlan badaj± du¿e kompozycje sk³adników. Koncentruj± siê tutaj na
 temacie zwi±zanym pocz±wszy od jêzyków programowania stosowanych do 
kompozycji systemów, do wyrafinowanych mechanizmów po³±czeñ. Oni te¿ 
wprowadzaj± pojêcie "³±czniki sk³adników", pierwsza klasa obiektów 
obejmuje protokó³ t³umaczenia który uzupe³nia spis sk³adników w 
interfejsie. My skupiamy siê na programowaniu modelu, umo¿liwiaj±cego 
dynamiczne ³±czenia </font><font>s</font><font face="Times New Roman">iê sk³adników. </font></p><font face="Times New Roman">
<p align="JUSTIFY">	George Heineman definiuje szkielet dla daj±cych siê 
przystosowaæ sk³adników oprogramowania, który próbuje zilustrowaæ 
technikê odbudowy sk³adników, które ponownie bêd± mog³y byæ u¿ywane. Ten
 szkielet jest jêzykowo i architektonicznie niezale¿ny. Nie dostarcza on
 jednak ogólnych mechanizmów do ³±czenia sk³adników. </p></font></dir><font face="Times New Roman">

</font><b><font face="Arial"><p>Utrzymywanie INCA po przez implementacjê </p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"><p align="JUSTIFY">Uwa¿amy to za
 bardzo wa¿ne dla wyra¼nego rozdzielenia elementów, które buduj± 
architekturê i infrastrukturê, szczególnie wtedy kiedy architektura musi
 migrowaæ ponad czasowo od jednej technologii do drugiej.</p>
<p align="JUSTIFY">	Najpierw decydujemy siê na stworzenie interfejsu 
u¿ytkownika z wykorzystaniem elementów appletu aby mo¿na by³o 
zapocz±tkowaæ przegl±danie stron internetowych. Ta decyzja spowodowa³a 
zastosowanie Java jako jêzyka programowania w odniesieniu do naszych 
sk³adników interfejsu u¿ytkownika i elementów serwera.</p>
</font><p align="JUSTIFY"><font face="Times New Roman">	Na poziomie 
architektury definiujemy grupê klas i interfejsów, które wyra¿aj± 
zasadnicze regu³y INCA. Na poziomie infrastruktury, tworzymy elementy 
architektoniczne przy pomocy specyficznych narzêdzi u¿ywanych jako 
udogodnienie w odniesieniu do wszystkich rozdzielanych elementów 
szkieletu. Ten rozdzielany element szkieletu powinien ustalaæ 
prze¼roczyst± lokalizacjê dla dostarczania</font><font> </font><font face="Times New Roman">pewnego
 zdalnego komunikatu i wyznaczaæ us³ugi serwisów. Na poziomie aplikacji,
 uzupe³nili¶my system za pomoc± aplikacyjnej instancji zawieraj±cej 
komponenty. Ilustracja 5 pokazuje ogólny obiektowy model dla elementów 
serwera przy trzech poziomach abstakc</font><font>ji.</font></p><font>
</font><font face="Times New Roman"><p align="JUSTIFY">Server INCA zawiera nastêpuj±ce klasy bazowe: Component, ServerHandle, Event i EventProxy.</p></font></dir><font face="Times New Roman">


</font><ul><font face="Times New Roman">
</font><dir><font face="Times New Roman">
<li><p align="JUSTIFY">Component(elementy) definiuj± us³ugi do³±czania i
 usuwania s³uchacza, i przywo³uj± z powrotem do obs³u¿enia wyników 
wys³anych do komponentów. </p></li>
</font><font></font><li><font>ServerHandle </font><font face="Times New Roman">definiuje trzy elementy niezbêdne do lokalizacji i ³±czenia okre¶lonych serwerów: </font></li><font face="Times New Roman">
</font><font><li>nazwa komponentu, </li>
<li>nazwa serwera, </li>
</font><font face="Times New Roman"><li>nazwa g³ównego (macierzystego) komputera w którym serwer rezyduje. </li>
<li><p align="JUSTIFY">Event definiuje zawarto¶æ zale¿n± od generowanego
 zdarzenia. Zdarzenia INCA s± wypisane na maszynie i ka¿de zdarzenie 
obiektu zawiera dwa poziomy informacji. Pierwszy poziom, który jest 
aplikacyjnie-niezale¿ny , zawiera SeeeionID identyfikuj±cy sesjê w 
jakiej wyniki zdarzenia zasz³y, i odwo³anie przez stacjê robocz± do 
InteractionManager, która ustawi³a SessionID Drugi poziom dodaje 
specyficzn± informacjê dla komponentu </p></li>
</font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">EventProxy
 jest przeznaczone dla zdarzenia poprzedzaj±cego wysy³anie i u¿ywa 
podstawowego rozdzielania szkieletu (obiektu do wezwania odbieraj±cego 
metodê zg³oszenia). Jego metoda forward() jest na wzór projektowanego 
wzorca Template Method . Metoda forward() wzywa metodê filter() do 
eliminacji pewnych zdarzeñ nie interesujacych dla s³uchacza, wtedy wi±¿e
 swój ServerHandle do specyficznego zdal</font><font>n</font><font face="Times New Roman">ego
 odwo³ania i ostatecznie przesy³a komunikat o zdarzeniu do odbiornika. 
Specyficzne podklasy EventProxy bêd± narzucaæ zmianê metody filter() 
jako niezbêdn±.</font></p></li></dir></ul><font face="Times New Roman">
</font></dir><font face="Times New Roman">
</font><dir><font face="Times New Roman">

</font><font><p align="JUSTIFY">&nbsp;</p>
</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys5.jpg" height="372" width="599"></p>
<i><font color="#000000" face="ARIAL" size="2"><p align="CENTER">Rys 5) Rodzajowe klasy serwera.</p>
</font></i><font size="2"><p align="JUSTIFY">&nbsp;</p>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Jak
 pokazano na rysunku 5 definiujemy proste implementacje odno¶nie tamtych
 specyficznych elementów architektonicznych stosownie do ustalonego 
rozdzielonego szkieletu w infrastrukturze poziomu</font><font color="#000000" face="Times New Roman">.
 W pewnych przypadkach tamtej implementacji (na przyk³ad, metody w 
SimpleComponentImpl które wspieraj± rejestracjê) bêdzie to wystarczaj±ce
 dla wielu elementów, chocia¿ komponenty serwera mog± narzucaæ zmianê 
owych metod w razie potrzeby. W poziomie aplikacji, ka¿dy element 
serwera, podobnie jak WelcomeImpl, rozszerz</font><font color="#000000">a</font><font color="#000000" face="Times New Roman"> rodzajow± implementacjê.</font></p><font color="#000000" face="Times New Roman">
</font><font color="#000000"><p align="JUSTIFY">&nbsp;</p></font></dir><font color="#000000">

</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/rys6.jpg" height="276" width="456"></p>
</font><dir><font face="Times New Roman"></font><i><font color="#000000" face="ARIAL" size="2"><p align="CENTER">Rys 6) Rodzajowy interfejs u¿ytkownika.</p>
</font></i><font color="#000000" size="2"><p align="JUSTIFY">&nbsp;</p>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Rysunek
 6 pokazuje porównywalny model dla elementów interfejsu u¿ytkownika, 
który jest w pewnym sensie prostszy ni¿ po stronie servera. W 
architekturze poziomu istnieje InteractionManager . W poziomie 
infrastruktury definiujemy konkretny AppletManager, który jest 
specjalizowany w InteractionManager dla ¶rodowiska stron internetowych. 
AppletManager jest sam w sobie odd</font><font>a</font><font face="Times New Roman">lonym,
 aplikacyjno-niezale¿nym serverem. My równie¿ definiujemy rodzajow± 
klasê SimpleApplet która wie jak znale¼æ swój AppletManager i jak 
zbieraæ w górnym kontek¶cie informacjê pozwalaj±c± na przej¶cie do 
zrzeszonego servera. . W poziomie aplikacji, pod</font><font>k</font><font face="Times New Roman">lasy z SimpleApplet definiuj± specyficzny interfejs u¿ytkownika i logiczn± aplikacjê. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Wprowadzenie tych
 poziomów abstrakcji oddzielnie pozwoli³o nam opisywaæ implementacje w 
ka¿dej strukturze, gdzie generowane, rodzajowe klasy dopasowywa³y siê do
 struktur</font><font>alnego modelu obiektu.</font></p></dir><font>

</font><b><font <p="" face="Arial">6. Zdalne wywo³anie metody w Java<p></p></font></b><font <p="" face="Arial"></font><dir><font <p="" face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Przy
 tworzeniu aplikacji z u¿yciem gniazdek napotykamy na wiele powa¿nych 
problemów. Dwa najwa¿niejsze z nich zosta³y zasygnalizowane w poni¿szym 
tek¶cie. Po pierwsze, gniazdka s³u¿± do przesy³ania tablic bajtów, 
napisów oraz prostych typów danych, takich jak liczby ca³kowite albo 
zmiennoprzecinkowe. Je¿eli nadawca chce wys³aæ bardziej skomplikowan± 
strukturê danych : na przyk³ad tablicê tablic, wektor obiektów 
nieznanego typu albo z³o¿ony obiekt zaw</font><font>i</font><font face="Times New Roman">eraj±cy
 podobiekty, musi on sam troszczyæ siê o to, jak zakodowaæ tê strukturê w
 postaci danych zrozumia³ych dla gniazdek. Z regu³y tak± zrozumia³± 
strukturê bêdzie tablica bajtów. Odbiorca musi siê zatroszczyæ o 
poprawne rozkodowanie, czyli odtworzenie p</font><font>r</font><font face="Times New Roman">zes³anej
 struktury danych. Sytuacja taka ma kilka negatywnych nastêpstw. 
Programi¶ci unikaj± bowiem czasoch³onnego kodowania obiektów i staraj± 
siê kodowaæ informacjê za pomoc± niewielkiej ilo¶ci danych o 
prymitywnych typach. Je¿eli ju¿ zdecyduj± siê na p</font><font>r</font><font face="Times New Roman">zesy³anie
 obiektów, poprawne napisanie metod zakodowania i rozkodowania zajmuje 
du¿o czasu i ³atwo w nich o b³êdy. Dla ka¿dego typu obiektu, który mo¿e 
byæ przesy³any, potrzebna jest tak¿e osobna para metod do kodowania i 
rozkodowywania. </font></p><font face="Times New Roman">
</font><font></font><p align="JUSTIFY"><font>Drugim problemem </font><font face="Times New Roman">zwi±zanym
 z u¿yciem gniazdek jest konieczno¶æ pisania kodu, który podejmuje 
decyzje na podstawie otrzymanych wiadomo¶ci. Kod taki musi znale¼æ siê w
 ka¿dym programie, który u¿ywa gniazdek do czego¶ wiêcej oprócz 
transferu danych </font></p><font face="Times New Roman">
</font><font></font><p align="JUSTIFY"><font>Zasygnalizowane problemy z</font><font face="Times New Roman">
 u¿yciem gniazdek (i innych protoko³ów wykorzystuj±cych strumienie 
bajtów) mog± zostaæ wyeliminowane przez abstrakcjê zdalnego wywo³ania 
metody (ang. remote method invocation - RMI). Podstawowym elementem 
sk³adowym tego rozwi±zania jest zdalny obiekt, czy</font><font>l</font><font face="Times New Roman">i
 taki, który mo¿e mie¶ciæ siê na dowolnym komputerze - zarówno na 
lokalnej maszynie u¿ytkownika, jak i na komputerze, do którego dostêp 
jest mo¿liwy tylko poprzez sieæ. RMI pozwala na wywo³ywanie metod na 
zdalnych obiektach oraz przekazywanie argumentów </font><font>d</font><font face="Times New Roman">o tych metod prawie w taki sam sposób, jak w sytuacji lokalnej, czyli w przypadku standardowego wywo³ania metody na obiekcie. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Sam pomys³ nie 
jest nowy -- stosuje siê go od lat w projektach badawczych oraz w do¶æ 
popularnym mechanizmie RPC (ang. remote procedure call). W ci±gu 
ostatnich kilkunastu miesiêcy pojêcie RMI sta³o siê te¿ znane w¶ród 
wielu u¿ytkowników Internetu. Powodem jest wprowadzenie RMI do 
specyfikacji Javy przez Sun Microsystems. Od wersji JDK 1.1, java.rmi 
jest pe³noprawnym, podstawowym p</font><font a<="" font=""><font face="Times New Roman">kietem Javy, a liczba aplikacji wykorzystuj±cych Java RMI stale ro¶nie. </font></font></p><font a<="" font=""><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Bardzo istotnym 
zagadnieniem jest przysz³o¶æ RMI. Niew±tpliwie Java staje siê wa¿nym 
elementem Internetu. Jest jednak pewne, ¿e spora czê¶æ aplikacji bêdzie 
nadal rozwijana w bardziej okrzep³ych jêzykach, takich jak C czy C++. 
Trzeba pamiêtaæ, ¿e dobrze dzia³aj±cych programów napisanych w jêzykach 
innych ni¿ Java jest sporo. Tymczasem Java RMI nie zapewnia mo¿liwo¶ci 
komunikacji z tymi programami (prace nad tym zagadnieniem trwaj±). J</font><font e<="" font=""><font face="Times New Roman">¿eli
 zatem np. klient napisany jest w Javie i wykorzystuje Java RMI, serwer 
te¿ musi korzystaæ z RMI. W przypadku gniazdek tego problemu nie ma. 
Klient mo¿e byæ napisany w Javie, a serwer na przyk³ad w C i oba bêd± 
wspó³pracowa³y tak, jakby do ich napisan</font><font>i</font><font a="" u¿yto="" tego="" samego="" jêzyka.="" <="" p="" face="Times New Roman">
</font></font></p><p align="JUSTIFY"><font e<="" font=""><font a="" u¿yto="" tego="" samego="" jêzyka.="" <="" p="" face="Times New Roman">RMI
 w szczególno¶ci u³atwia znajdowanie zdalnych obiektów, wywo³ywanie 
zdalnych metod oraz przesy³anie z³o¿onych struktur danych. Postaramy siê
 przybli¿yæ czytelnikom zagadnienia zwi±zane ze zdalnym wywo³aniem 
metody, a przede wszystkim wykorzystanie Java RMI do pisania aplikacji 
rozproszonych. Przyk³adem bêdzie serwer przechowuj±cy wiadomo¶ci 
zostawiane i odbierane przez klientów. Omówimy sposób tworzenia zdalnych
 obiektów, ich lokalizacji przez klientów, przekazywanie argumen</font><font>t</font><font face="Times New Roman">ów
 zdalnemu wywo³aniu metody, rolê zdalnych interfejsów i obiektów 
zastêpczych oraz ¶rodowisko tworzenia i wykonywania programów 
stworzonych przy wykorzystaniu Java RMI. </font></font></p></font></dir><font a<="" font=""><font e<="" font=""><font face="Times New Roman">

</font><b><font face="Arial"><p>7. Serwer wiadomo¶ci </p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Konstruowany
 przez nas serwer ma oferowaæ u¿ytkownikom mo¿liwo¶æ zostawiania 
wiadomo¶ci dla innych u¿ytkowników oraz odczytywania wiadomo¶ci 
przychodz±cych od innych u¿ytkowników. Wiadomo¶æ mo¿e byæ chroniona 
has³em, tzn. zostawiaj±cy j± u¿ytkownik mo¿e wyspecyfikowaæ has³o, które
 musi zostaæ podane przez osobê chc±c± odczytaæ ten komunikat. Wszystkie
 przes³ane komunikaty s± przechowywane na centralnym serwerze; 
u¿ytkownicy kontaktuje siê z nim za pomoc± programów-klientów. 
Komunikaty nie chronione has³em to obiekty klasy java.lang.String, 
natomiast komunikaty chronio</font><font>n</font><font face="Times New Roman">e s± obiektami klasy </font>EncryptedMessage<font face="Times New Roman">.
 Jedyna metoda tej klasy pozwala na weryfikacjê has³a; je¿eli 
weryfikacja zakoñczy siê sukcesem, getMessage zwraca w³a¶ciw± wiadomo¶æ.
 Istotnym elementem definicji klasy EncryptedMessage jest to, ¿e 
implementuje ona interfejs java.io.Serializable. Oznacza to, ¿e 
programista nie musi implementowaæ ¿adnych dodatkowych metod, za¶ 
obiekty danej klasy mog± byæ przekazywane jako argumenty metodom 
wywo³ywanym na zdalnych obiekt</font><font>a</font><font face="Times New Roman">ch. Wyja¶nione to zostanie dok³adniej w dalszej czê¶ci artyku³u. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Tu jest kod implementuj±cy </font>serwer<font face="Times New Roman">.
 Klasa MessageServer ró¿ni siê od dowolnej innej klasy o podobnym 
przeznaczeniu, ale takiej, która nie bêdzie u¿ywana razem z RMI. Po 
pierwsze, klasa MessageServer jest podklas± klasy 
java.rmi.UnicastRemoteObject. Oznacza to m.in., ¿e metody wywo³ywane na 
obiektach tej klasy bêd± wykorzystywa³y do komunikacji protokó³ sieciowy
 TCP/IP - zapewnione wiêc bêdzie niez</font><font>a</font><font face="Times New Roman">wodne
 przesy³anie danych (o ile nie nast±pi np. powa¿na awaria sieci). Po 
drugie, klasa MessageServer implementuje zdalny interfejs 
MessageServerIf</font><font face="Times New Roman"> - rozszerza on 
interfejs java.rmi.Remote. Ka¿da klasa implementuj±ca MessageServerIf 
bêdzie zatem implementowa³a tak¿e java.rmi.Remote. Ponadto, obiekty klas
 implementuj±cych java.rmi.Remote (i tylko one!) mog± byæ zdalnymi 
obiektami, czyli takimi, na których metody mog± za pomoc± RMI wywo³ywaæ 
programy Javy wykonuj±ce siê </font><font>n</font><font face="Times New Roman">a
 innych komputerach. Obiekty klasy MessageServer mog± wiêc byæ obiektami
 zdalnymi. Istotn± cech± interfejsu MessageServerIf jest te¿ to, ¿e 
wywo³ywanie zadeklarowanych tam metod mo¿e spowodowaæ powstanie wyj±tku 
java.rmi.RemoteException. Wyj±tek ten s³u¿</font><font>y</font><font face="Times New Roman">
 Java RMI do sygnalizowania problemów z dzia³aniem mechanizmów RMI, np. 
zerwanie po³±czenia sieciowego podczas wykonywania metody na zdalnym 
obiekcie albo przerwanie dzia³ania komputera, na którym zlokalizowany 
jest zdalny obiekt. </font></p><font face="Times New Roman">
</font><font></font><p align="JUSTIFY"><font>Opisane kodowanie zdalny</font><font face="Times New Roman">ch
 obiektów przy u¿yciu Java RMI nie wystarcza jeszcze do stworzenia 
aplikacji rozproszonej. Brakuj±cym elementem jest mo¿liwo¶æ odnalezienia
 w sieci interesuj±cego nas zdalnego obiektu. By zrozumieæ, jak RMI 
pozwala obiektom na znajdowanie siê w sieci, p</font><font>r</font><font face="Times New Roman">ze¶ledzimy
 dzia³ania, dziêki którym obiekt klasy MessageServer mo¿e byæ 
wykorzystywany za pomoc± RMI przez inne obiekty. Pierwszym krokiem jest 
zarejestrowanie obiektu w spisie (ang. registry) zdalnych obiektów Javy,
 rezyduj±cych na danym komputerze. Raze</font><font>m</font><font face="Times New Roman">
 z JDK 1.1 oraz pó¼niejszymi wersjami dostarczany jest program 
rmiregistry, który powinien byæ uruchomiony na danym komputerze przed 
tworzeniem zdalnych obiektów. Program ten to w³a¶nie spis lokalnie 
rezyduj±cych zdalnych obiektów (czyli obiektów implemen</font><font>t</font><font face="Times New Roman">uj±cych
 interfejs java.rmi.Remote), pozwalaj±cy programom Javy na lokalizacjê 
zdalnych obiektów, a tak¿e na otrzymywanie do nich referencji, 
umo¿liwiaj±cych wywo³ywanie zdalnych metod. Poni¿sze dwie linie kodu 
demonstruj±, w jaki sposób stworzony zostaje </font><font>o</font><font face="Times New Roman">biekt dostêpny dla innych programów Javy: </font></p><font face="Times New Roman">
</font><i><font><p align="JUSTIFY">MessageServer messageServer = new MessageServer();</p>
</font></i><p align="JUSTIFY"><font>Naming.rebind("SimpleMessageServer", messageServer);</font></p><font>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Pierwsza
 linia tworzy obiekt za pomoc± wywo³ania konstruktora. Druga wo³a 
statyczn± metodê rebind klasy java.rmi.Naming, powoduj±c±, ¿e spis 
zdalnych obiektów ulokowanych na lokalnym komputerze jest "proszony" o 
przechowanie obiektu messageServer i zwi±zanie z nim nazwy 
SimpleMessageServer. Nazwa ta pozwoli innym obiektom na znalezienie 
messageServer w sieci. Se</font><font>r</font><font face="Times New Roman">wer wiadomo¶ci, utworzony na podstawie Java RMI jest zatem gotowy. W jaki sposób klienci mog± go odnale¼æ? </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">W przypadku 
programowania z gniazdkami programy rozproszone lokalizuj± swoje 
komponenty za pomoc± nazw komputerów oraz numerów portów. RMI tak¿e 
wykorzystuje internetowe adresy komputerów, ale zamiast ma³o mówi±cych 
numerów portów pozwala na zwi±zanie ze zdalnymi obiektami nazw w postaci
 napisów. W naszym przyk³adzie takim napisem, identyfikuj±cym serwer 
wiadomo¶ci w obrêbie danego komputera jest Sim</font><font>p</font><font face="Times New Roman">leMessageServer.
 Znaj±c ten identyfikator oraz wiedz±c, na którym komputerze znajduje 
siê serwer, klienci mog± ³atwo nawi±zaæ z nim kontakt: </font></p><font face="Times New Roman">
</font><i><font><p align="JUSTIFY">Object obj=Naming.lookup("//ciastko.cis.com.pl/SimpleMessageServer");</p>
<p align="JUSTIFY">MessageServerIf mServer = (MessageServerIf) obj;</p>
</font></i><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Kod
 ten jest wykonywany przez ka¿dego klienta w celu uzyskania mo¿liwo¶ci 
kontaktowania siê z serwerem (poprzedni fragment kodu, demonstruj±cy 
tworzenie obiektu typu MessageServer, wykonywany jest na komputerze, na 
którym rezyduje serwer). Pierwsza linia korzysta z metody lookup klasy 
java.rmi.Naming i w rezultacie zwraca obiekt zastêpczy (ang. proxy 
object) mServer. Jedyne podobieñstwo miêdzy obiektem zastêpczym dla 
danego zdalnego obiektu (mServer) a tym w³a¶nie obiektem zdalnym 
(messageServer) pole</font><font>g</font><font face="Times New Roman">a 
na tym, ¿e oba implementuj± te same zdalne interfejsy, rozszerzaj±ce 
java.rmi.Remote. Dziêki temu obiekt zastêpczy zwrócony przez metodê 
lookup mo¿na rzutowaæ na dowolny zdalny interfejs implementowany przez 
dany zdalny obiekt - w naszym przypadku jest </font><font>to interfejs MessageServerIf. </font></p><font>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Metody
 rebind i lookup uzupe³niaj± siê, pierwsza z nich wi±¿e nazwê, 
identyfikator z obiektem, druga za¶ wykorzystuje tê nazwê do 
odnalezienia obiektu. Argumentem dla metody lookup jest napis w postaci 
//adresKomputera/identyfikatorObiektu. W naszym przyk³adzie podana jest 
tekstowa postaæ adresu komputera: ciastko.cis. com.pl, ale mo¿na u¿ywaæ 
równie¿ numerycznych adresów internetowych. Identyfikatorem jest dobrze 
ju¿ znany napis SimpleMessageServer. Poniewa¿ lookup zwraca obi</font><font>e</font><font face="Times New Roman">kty
 typu java.lang.Object, konieczne jest u¿ycie rzutowania typów w celu 
otrzymania obiektu o typie umo¿liwiaj±cym bezpo¶rednie wywo³ywanie metod
 (druga linia fragmentu kodu). Zauwa¿my, ¿e rzutujemy na typ interfejsu 
MessageServerIf, a nie na typ MessageS</font><font>e</font><font face="Times New Roman">rver.
 Wynika to st±d, ¿e klient nie musi (a w wielu sytuacjach po prostu nie 
mo¿e) znaæ dok³adnego typu zdalnego obiektu-serwera. Decyduj± tu wzglêdy
 zarówno techniczne (np. klasa serwera wraz z innymi klasami, 
koniecznymi do poprawnego za³adowania, mo¿e </font><font>m</font><font face="Times New Roman">ieæ
 bardzo du¿y rozmiar i ¶ci±ganie jej podczas wywo³ywania lookup mo¿e 
d³ugo trwaæ), jak i konieczno¶æ ochrony kodu. Problem ochrony danych 
wi±¿e siê z ponoszeniem du¿ych nak³adów finansowych oraz nierzadko 
przynosi rezultaty w postaci nowych algorytmów </font><font>a</font><font face="Times New Roman">lbo
 rozwi±zañ. Nie jest zatem po¿±dane, ¿eby skompilowane klasy Javy, 
stosunkowo ³atwo poddaj±ce siê dekompilacji (nawet pomimo istnienia 
programów maj±cych utrudniæ otrzymanie kodu ¼ród³owego ze skompilowanych
 klas), opuszcza³y dobrze strze¿one komputery</font><font> </font><font face="Times New Roman">posiadacza cennego oprogramowania. Java RMI, udostêpniaj±c zdalny obiekt poprzez obiekt zastêpczy, rozwi±zuje opisane problemy. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Ró¿nice miêdzy 
obiektami zastêpczymi a w³a¶ciwymi zdalnymi obiektami wynikaj± z funkcji
 obiektów zastêpczych. Ich rol± jest umo¿liwienie wywo³ania metod w taki
 sam sposób, w jaki wywo³ywaæ je mo¿na na zwyczajnych obiektach Javy. 
Inaczej mówi±c, to dziêki obiektom zastêpczym u¿ywanie Java RMI 
"wygl±da" prawie tak samo jak wykorzystywanie zwyczajnych obiektów Javy.
 Dla lepszego zro</font><font>z</font><font face="Times New Roman">umienia
 roli obiektów zastêpczych popatrzmy, co siê dzieje, gdy klient wywo³a 
metodê storeEncryptedMessage na obiekcie zastêpczym mServer:</font></p><font face="Times New Roman">
</font><i><font><p align="JUSTIFY">EncryptedMessage msg = new EncryptedMessage("Wazny tekst", "Haslo: Hans Klos"); mServer.storeEncryptedMessage(msg); </p>
</font></i><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Niezauwa¿alnie
 dla klienta zaczyna dzia³aæ kod Java RMI. Najpierw argumenty przekazane
 wywo³aniu s± zakodowywane jako tablica bajtów. Nastêpnie tablica ta 
przesy³ana jest do komputera, na którym umieszczony jest serwer. Bajty 
reprezentuj±ce argumenty s± r</font><font o<="" font=""><font face="Times New Roman">zkodowane
 i odtwarzane s± oryginalne argumenty. W naszym przyk³adzie, odtworzony 
zostaje obiekt typu EncryptedMessage. Na obiekcie serwera 
(messageServer, a wiêc w³a¶ciwym, a nie zdalnym) wywo³ywana jest metoda 
storeEncryptedMessage. Po jej wykonaniu rezu</font><font>l</font><font face="Times New Roman">tat
 jest kodowany do tablicy bajtów i zwracany klientowi (w naszym 
przyk³adzie metoda nie zwraca ¿adnych warto¶ci, wiêc tablica ta bêdzie 
pusta). Kod RMI po stronie klienta przetwarza otrzymane informacje, po 
czym powoduje, ¿e nastêpuje powrót z metody st</font><font o<="" font=""><font face="Times New Roman">reEncryptedMessage
 wywo³anej na mServer i klient (dany w±tek klienta) mo¿e kontynuowaæ 
wykonywanie swojego programu. Je¿eli wykonanie zdalnej metody 
spowodowa³oby powstanie jakiegokolwiek wyj±tku, zarówno zwi±zanego z 
kodem samej zdalnej metody, jak i z p</font><font>r</font><font face="Times New Roman">oblemami sieciowymi, klient zostanie poinformowany o tym przez stosowny wyj±tek. </font></font></font></p><font o<="" font=""><font o<="" font=""><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Po utworzeniu 
serwera oraz klienta, klient mo¿e korzystaæ z us³ug serwera poprzez 
wywo³ywania metod na odpowiednim obiekcie zastêpczym, zupe³nie tak samo 
jak w przypadku wywo³ywania metod na obiektach lokalnych. Jedyn± ró¿nic±
 jest to, ¿e ka¿da z takich zdalnych metod mo¿e spowodowaæ powstanie 
sytuacji wyj±tkowej, zwi±zanej z sieciowym charakterem wywo³ywanej 
zdalnej operacji. Dlatego konieczne jest zapewnienie obs³ugi tworzo</font><font>n</font><font face="Times New Roman">ego
 w takich sytuacjach wyj±tku java.rmi.RemoteException. Podobnie jak w 
przypadku innych wyj±tków Javy nie jest wymagane "ciasne" oplatanie 
wywo³ania zdalnej metody przez try oraz catch -- mo¿na np. miêdzy tymi 
dwoma s³owami kluczowymi umie¶ciæ wiêkszy f</font><font>r</font><font face="Times New Roman">agment programu. Komunikacja oraz zale¿no¶ci miêdzy opisanymi obiektami oraz interfejsami s± zbiorczo przedstawione na rysunku. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Wyja¶nienia 
wymaga jeszcze konsekwencja implementowania przez dan± klasê interfejsu 
java.io.Serializable w kontek¶cie RMI. Przypomnijmy, ¿e tak± klas± jest 
EncryptedMessage. Gdyby nie implementowa³a ona java.io.Serializable, nie
 mog³aby byæ przekazywana ¿adnej zdalnej metodzie. Wymieniony interfejs 
nie ma ¿adnych metod ani pól, jest jedynie informacjê dla Javy, ¿e dla 
danej klasy</font><font> </font><font face="Times New Roman">trzeba 
zapewniæ metody serializacji, czyli pakowania jej obiektów w strumieñ 
bajtów oraz rekonstrukcji klasy z takiego "p³askiego" strumienia. 
Wiêkszo¶æ klas z pakietów java.lang oraz java.util jest serializowalna. 
Serializowalne s± te¿ np. prymitywne typ</font><font>y</font><font face="Times New Roman">
 danych w Javie, takie jak int, char, oraz tablice tych typów. 
Przyk³adowo, java.lang.String, wchodz±ca w sk³ad klasy EncryptedMessage,
 jest serializowalna. Ka¿da klasa sk³adowa klasy serializowalnej musi 
byæ serializowalna. Gdyby na przyk³ad String nie i</font><font>m</font><font face="Times New Roman">plementowa³
 java.io.Serializable, obiekty klasy EncryptedMessage nie by³yby 
serializowalne, a co za tym idzie obiekty takie nie mog³yby byæ 
argumentami zdalnych metod. Konieczno¶æ implementowania 
java.io.Serializable dotyczy wszystkich obiektów, które w w</font><font>y</font><font face="Times New Roman">niku
 wywo³ywania zdalnych metod mog± byæ przesy³ane przez sieæ. Oprócz 
obiektów-argumentów dotyczy to wiêc tak¿e obiektów zwracanych przez 
zdalne metody. Nale¿y podkre¶liæ tutaj, ¿e implementowanie przez dan± 
klasê interfejsu Serializable jest rozszerzeni</font><font>e</font><font face="Times New Roman">m
 mo¿liwo¶ci stosowania tej klasy, a nie uszczupleniem -- mo¿e ona byæ w 
dalszym ci±gu wykorzystywana jako pe³noprawna klasa standardowej Javy. </font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Istotn± ró¿nic± 
miêdzy "zwyczajn±" Jav± a Java RMI jest to, ¿e argumenty przekazywane 
zdalnym metodom s± kopiowane. Oznacza to, ¿e ¿adne ze zmian warto¶ci pól
 obiektów przekazanych zdalnej metodzie nie bêd± widoczne po stronie 
wywo³uj±cego tê metodê. Nie jest to prawd± w przypadku standardowego 
wywo³ania metody w Javie, gdzie zmiany warto¶ci pól argumentów s± zach</font><font>o</font><font face="Times New Roman">wywane
 tak¿e po zakoñczeniu wywo³ania danej metody. Java RMI oferuje tak¿e 
sporo innych mo¿liwo¶ci, np. wskazywanie pól obiektów, które nie bêd± 
serializowane przy przesy³aniu obiektu przez sieæ. Pozwala to m.in. na 
lokalne obliczenia z u¿yciem obiektów z</font><font a<="" font=""><font wieraj±cych="" tajne="" informacje,="" takie="" jak="" numery="" kart="" kredytowych="" czy="" dane="" dotycz±ce="" zarobków.="" pola="" z="" danymi,="" które="" nie="" powinny="" byæ="" przesy³ane="" przez="" sieæ="" ze="" wzglêdów="" bezpieczeñstwa,="" s±="" wskazywane="" s³owem="" kluczowym="" transient.="" te="" bêd±="" mia³y="" warto¶æ="" 0="" albo<="" font="" face="Times New Roman"><font> </font><font face="Times New Roman">null,
 zale¿nie od typu pola, w odtworzonym u odbiorcy obiekcie. W¶ród 
zaawansowanych zagadnieñ zwi±zanych z Java RMI warto zwróciæ uwagê na 
automatyczne zwalnianie zdalnych obiektów, opieraj±ce siê na liczeniu 
zdalnych referencji (Java zapewnia automatycz</font><font>n</font><font face="Times New Roman">e
 zarz±dzanie pamiêci±), wykorzystanie klasy java.rmi. 
ReMISecurityManager do kontroli dzia³ania zdalnych wywo³añ metod czy 
wreszcie komunikacjê z u¿yciem RMI przez firewalle. </font></font></font></p></font></font></dir><font o<="" font=""><font o<="" font=""><font a<="" font=""><font wieraj±cych="" tajne="" informacje,="" takie="" jak="" numery="" kart="" kredytowych="" czy="" dane="" dotycz±ce="" zarobków.="" pola="" z="" danymi,="" które="" nie="" powinny="" byæ="" przesy³ane="" przez="" sieæ="" ze="" wzglêdów="" bezpieczeñstwa,="" s±="" wskazywane="" s³owem="" kluczowym="" transient.="" te="" bêd±="" mia³y="" warto¶æ="" 0="" albo<="" font="" face="Times New Roman"><font face="Times New Roman">

</font><b><font face="Arial"><p>8. Implementacja RMI Javy</p></font></b><font face="Arial"></font><dir><font face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Nasza
 pierwsza INCA implementacja u¿ywa³a Javy RMI do zdalnego dorêczenia 
informacji i servisu nazw . Ka¿dy sk³adnik serwera by³ zaimplementowany 
jako zdalny obiekt RMI. Czê¶æ sk³adowa klienta, je¿eli istnia³a by³a 
zaimplementowana jako aplet. Od czasu przegl±dania efektu dzia³ania w 
neutralnym trybie, ka¿d</font><font>a</font><font face="Times New Roman">
 pozycja która musia³a byæ przechowywana, by³a wysy³ana apletowi 
podkomponentu serwera. Sk³adniki apletu tak¿e zawiera³y odwo³ania do 
jego objektu AppletMenager. </font></p><font face="Times New Roman">
<p align="JUSTIFY">My realizowali¶my konfiguracjê programu narzêdziowego
 podczas wykonywania siê prostej aplikacji Javy, która zarz±dza³a 
spójno¶ci± pomiêdzy aktywnym sk³adnikiem oddzia³ywuj±cym wzajemnie z ich
 wewnêtrznie wbudowanymi po³±czeniami obiektów. Zaimplementowali¶my 
tak¿e aplet zarz±dzaj±cy sterowalnym na odleg³o¶æ obiektem Javy.</p>
</font><font></font><p align="JUSTIFY"><font>Dla zdalnego obiektu, nas</font><font face="Times New Roman">za
 sk³adowa klasy musi implementowaæ interfejs java.rmi.Remote. W dodatku,
 klasa SimpleComponentImpl musi zawieraæ interfejs SimpleComponent i 
rozszerzon± klasê java.rmi.server.UnicastRemoteObject. Ta druga klasa 
dostarcza wsparcia dla pakowanego obiektu </font><font>t</font><font face="Times New Roman">ak samo jak w przypadku zdalnego obiektu dla pojedyñczej z niczym nie powi±zanej </font><font color="#000000" face="Times New Roman">aplikacji.
 Ostatecznie, dla ka¿dej czê¶ci sk³adowej aplikacji, takiej jak Welcome,
 musimy definiowaæ interfejs który rozszerza interfejs komponentu i 
definiuje specjaln± metodê zdalnego dostarczenia do servera Welcome. Ten
 interfejs jest implementowany w klasie WelcomeImpl. </font></p><font color="#000000" face="Times New Roman">
</font><p align="JUSTIFY"><font color="#000000" face="Times New Roman">W oparciu o kilka umownych procedur , stworzyli¶my server obiektowy jako sterowalne na odleg³o¶æ obiekty. Wygenerowali¶my </font><font>wymagane odcinki i szkielet dla z</font><font face="Times New Roman">dalnych
 obiektów przy pomocy wykonujacej siê skompilowanej implementacji klasy 
przez zdalne wywo³anie metody kompilowania programu Javy, rmic.</font></p></dir><font face="Times New Roman">

</font><b><font face="Arial"><p>9. Kilka s³ów o Corb-ie</p></font></b><dir><b><font face="Arial">

</font><font></font></b><font></font><p align="JUSTIFY"><font><b>Common Object Request Broker Architekture</b></font><font face="Times New Roman"> (CORBA) definiuje strukturê umo¿liwiaj±c± tworz</font><font>enie obiektowo zorientowanych rozproszonych aplikacji. </font></p><font>
</font><font face="Times New Roman"><p align="JUSTIFY">Poni¿szy rysunek przedstawia dzia³anie Object Request Broker.</p>
</font><font color="#000000"><p align="JUSTIFY">&nbsp;</p></font></dir><font color="#000000">

</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/pol1.jpg" height="410" width="710"></p>
<i><font color="#000000" face="ARIAL" size="2"><p align="CENTER">Rys 7) Dzia³anie Object Request Broker</p>
</font></i><b><font color="#000000" face="Arial">
</font></b><font color="#000000" face="Arial"></font><dir><font color="#000000" face="Arial"><b>

<p align="JUSTIFY">Obiekty w CORBA</p></b></font><dir><font color="#000000" face="Arial"><b>

</b></font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Obiekty
 te s± standardowymi obiektami implementowanymi w jednym z obs³ugiwanych
 przez CORBA jêzyków programowania (Java, C++, Smalltalk). Za pomoc± 
kilku odwo³añ do interfejsu programisty ORB mo¿na uczyniæ obiekty 
dostêpnymi w sieci dla klientów. Klienci mog± byæ napisani w jednym z 
obs³ug</font><font>i</font><font face="Times New Roman">wanych jêzyków programowania i mog± odwo³ywaæ siê do metod obiektów CORBA u¿ywaj±c zwyk³ej sk³adni jêzyka programowania.</font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Chocia¿ obiekty 
CORBA s± implementowane przy u¿yciu standardowych jêzyków programowania,
 ka¿dy obiekt posiada jasno zdefiniowany przy u¿yciu </font><b><font>CORBA Interface Definition Language</font></b><font face="Times New Roman">
 (IDL) interfejs. Definicja interfejsu specyfikuje bez robienia 
dodatkowych za³o¿eñ co do implementacji obiektu, które metody bêd± 
dostêpne dla klienta.</font></p><font face="Times New Roman">
<p align="JUSTIFY">Aby wywo³ywaæ metody obiektu CORBA klient potrzebuje 
tylko definicjê IDL obiektu. Klient nie musi znaæ takich szczegó³ów jak 
jêzyk programowania u¿yty do implementacji obiektu, po³o¿enie obiektu w 
sieci czy system operacyjny pod jakim obiekt jest uruchomiony.</p>
</font><font></font><p align="JUSTIFY"><font>Rozdzielenie interfejsu obiektu i jego implementacji ma ki</font><font face="Times New Roman">lka
 zalet. Pozwala na przyk³ad zmieniæ jêzyk programowania u¿yty do 
implementacji obiektu bez zmieniania sposobu dostêpu klienta do obiektu.
 Pozwala równie¿ na uczynienie istniej±cych ju¿ obiektów dostêpnymi 
poprzez sieæ.</font></p></dir><font face="Times New Roman">

</font><b><font color="#000000" face="Arial"><p align="JUSTIFY">Struktura aplikacji CORBA</p></font></b><font color="#000000" face="Arial"></font><dir><font color="#000000" face="Arial"><b>

</b></font><font></font><p align="JUSTIFY"><font>Pierwszy</font><font face="Times New Roman">m
 krokiem w tworzeniu aplikacji CORBA jest zdefiniowanie interfejsów do 
obiektów w systemie przy u¿yciu CORBA IDL. Nastêpnie nale¿y skompilowaæ 
interfejsy u¿ywaj±c kompilatora IDL.</font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Kompilator IDL z definicji w jêzyku IDL tworzy kod ¼ród³owy w Javie. Kod te</font><font>n zawiera <u>client stub code</u></font><font face="Times New Roman"> pozwalaj±cy na tworzenie programów klienta oraz </font><u><font>server skeleton code</font></u><font face="Times New Roman">, który pozwala na implementacjê obiektów CORBA.</font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Je¿eli klient wywo³uje metodê obiektu, do którego wcze¶niej nie by³o odwo³añ ORB zwraca siê do bazy danych zwane</font><font>j <b>Implementation Respository</b></font><font face="Times New Roman"> aby ustaliæ dok³adnie do którego obiektu ma zostaæ przes³ane ¿±danie wywo³ania metody. </font></p></dir><font face="Times New Roman">

</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/pol2.jpg" height="390" width="720"></p>
<i><font color="#000000" face="ARIAL" size="2"><p align="CENTER">Rys 8) Wywo³anie metody obiektu Corba</p>
</font></i>&nbsp;<b><font color="#000000" face="Arial"><p align="JUSTIFY">Struktura dynamicznej aplikacji CORBA.</p>
</font></b><font color="#000000"><p align="JUSTIFY"></p></font><dir><font color="#000000">

</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Trudno¶ci±
 w zwyk³ym programowaniu CORBA jest to, ¿e programy klienta mog± 
wywo³ywaæ jedynie metody obiektów, których interfejsy by³y znane w 
momencie kompilacji. Je¿eli klient chce otrzymaæ w trakcie uruchomienia 
informacjê o interfejsie IDL obiektu to potrzebne j</font><font>e</font><font face="Times New Roman">st alternatywne, dynamiczne podej¶cie do programowania CORBA.</font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">Program klienta mo¿e w trakcie swojego dzia³ania informacje o interfejsach implementowanych przez obiekty w siec z </font><b><font>CORBA Interface Respository</font></b><font face="Times New Roman">. Klient mo¿e wtedy wywo³ywaæ metody obiektów u¿ywaj±c sk³adnika ORB nazywanego </font><b><font>Dynamic call Interface</font></b><font> (DII).</font></p><font>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">CORBA
 umo¿liwia równie¿ dynamiczne programowanie serwera. Program CORBA mo¿e 
otrzymaæ wywo³ania metod poprzez interfejsy IDL, dla których nie 
istnieje ¿aden obiekt CORBA. U¿ywaj±c sk³adnika ORB nazy</font><font>wanego <b>Dynamic Skeleton Interface</b></font><font face="Times New Roman"> (DSI), serwer mo¿e sprawdziæ strukturê wywo³añ tych metod i zaimplementowaæ je w trakcie dzia³ania.</font></p></dir><font face="Times New Roman">

</font><b><font color="#000000" face="Arial"><p align="JUSTIFY">Komunikacja pomiêdzy sk³adnikami ORB</p></font></b><font color="#000000" face="Arial"></font><dir><font color="#000000" face="Arial"><b>

</b></font><font face="Times New Roman"><p align="JUSTIFY">Sk³adniki ORB
 czyni± rozproszenie programów niewidocznym dla programistów sieciowych.
 Aby to osi±gn±æ musz± siê komunikowaæ ze sob± poprzez sieæ.</p>
</font><p align="JUSTIFY"><font face="Times New Roman">W wielu sieciach 
istniej± ró¿ne implementacje ORB. Programy utworzone za pomoc± jednej 
implementacji musz± wspó³dzia³aæ ze stworzonymi za pomoc± innej. Aby to 
zapewniæ CORBA specyfikuje standardowy protokó³ sieciowy nazywany </font><b><font>Internet Inter-ORB Protocol</font></b><font face="Times New Roman"> (IIOP), za pomoc± którego komunikuj± siê sk³adniki ORB.</font></p><font face="Times New Roman">
</font><b><u><font></font></u></b><u><font></font></u><font><p align="JUSTIFY"><u><b>Object Management Architecture </b></u>(OMA)</p>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">&nbsp;ORB jest jednym ze sk³adników OMA. Architektura ta definiuje strukturê dla komunikacji pomiêdzy r</font><font>ozproszonymi obiektami. Zawiera on cztery elementy:</font></p></dir><font>


</font><ul><font>
</font><dir><font>
<li>Obiekty aplikacji </li>
<li>Object Request Broker </li>
</font><font face="Times New Roman"><li>Us³ugi CORBA (CORBAservices) </li>
<li>U³atwienia CORBA (CORBAfacilities)</li></font></dir></ul><font face="Times New Roman">
</font></dir><font face="Times New Roman">
</font><dir><font face="Times New Roman">

</font><p align="JUSTIFY"><font face="Times New Roman">&nbsp;Obiekty 
aplikacji s± obiektami które implementuj± zdefiniowane przez programistê
 interfejsy IDL. Te obiekty komunikuj± siê miêdzy sob± oraz z </font><b><font>CORBAservices</font></b><font> i <b>CORBAfacilities </b></font><font face="Times New Roman">,
 za po¶rednictwem ORB. CORBAservices i CORBAfacilities s± zbiorem 
obiektów które implementuj± interfejsy IDL zdefiniowane przez CORBA oraz
 dostarczaj± us³ugi dla pew</font><font>nych rozproszonych aplikacji</font></p><font>
</font><font color="#000000"><p align="JUSTIFY"></p>
<p align="JUSTIFY"></p></font></dir><font color="#000000">

</font><p align="CENTER"><img src="Architektura%20oprogramowania%20system%C3%B3w%20rozproszonych_pliki/pol3.jpg" height="359" width="604"></p>
<i><p font="" face="ARIAL" align="CENTER">Rys 9) Object Management Architecture</p>
</i></font><i><font size="4"><p align="JUSTIFY"></p>
</font></i><b><font face="Arial"></font></b><font face="Arial"><p><b>Implementacja Corby</b> </p></font><dir><font face="Arial">

</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Do
 implementacji INCA u¿ywali¶my równie¿ Visigenic Visibroker dla Javy, 
wersji 3.2. Ka¿dy komponent servera i AppletManager by³y implementowane 
jako obiekty Corby. Wchodz±ce w sk³ad aplety s± w du¿ej mierze 
niezmienialne wed³ug wykonania Javy RMI. Pierwsza modyfikacja powstaje w
 momencie gdy obiekty maj± do czynienia z nieznacznie ró¿nymi w</font><font>y</font><font face="Times New Roman">j±tkami narzucanymi przez zdalne metody na serwerach.</font></p><font face="Times New Roman">
</font><p align="JUSTIFY"><font face="Times New Roman">	Wszystkie 
obiekty Corby, w³±czaj±c nasze czê¶ci sk³adowe klasy s± pochodnymi z 
klasy org.omg.Corba.Object. Wa¿ne jest tutaj zapisanie ustawieñ plików 
IDL, które opisywa³y interfejs dla architektury elementów i sk³adników 
aplikacji. Te znajdowa³y zasilanie w Visibroker compiler idl2java do 
generowania odpowiedniego szkieletu, jak i dodatkowo pomocniczych klas. 
Ten proces jest jednak bardziej skomplikowany ni¿ w Java RMI, poniewa¿ 
utworzenie wygenerowany</font><font>c</font><font face="Times New Roman">h klas jest naprawdê d³ugie.</font></p></dir><font face="Times New Roman">

</font><b><font face="Arial"></font></b><font face="Arial"><p><b>Ewaluacja</b> </p></font><dir><font face="Arial">

</font><font face="Times New Roman"><p align="JUSTIFY">Oceniane obiekty INCA zamodelowane w charakterystyczny sposób architektoniczny dostarczaj± nastêpuj±cego wgl±du.</p></font></dir><font face="Times New Roman">


</font><ul><font face="Times New Roman">
</font><dir><font face="Times New Roman"></font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Component
 - sk³adniki rozdrobnione adoptowali¶my w pewnym stopniu na nowo. Ka¿dy 
obiekt jest, w efekcie, ma³ym pakietem client-server. Jak do tej pory to
 wszystko pracowa³o dobrze , ale przysz³e u¿ycie tych elementów, 
zw³aszcza w innym kontek¶cie mog³oby nie byæ najlepszym posuniêciem. 
Do¶wiadczenie pozwala nam stwierdziæ i¿, dawniej implementowali¶my c</font><font>z</font><font face="Times New Roman">ê¶ci
 elementów w infrastrukturze rdzenia a pierwszy z dwóch komponentów, 
³atwo móg³ byæ dodany do nowych komponentów bez zak³ócania ju¿ 
istniej±cych. </font></p></li><font face="Times New Roman">
</font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Distributed control (sterowanie rozproszone) - INCA nie ma ¿adnych pojedyñczych sk³adników</font><font color="#000000">, które kont</font><font color="#000000" face="Times New Roman">rolowa³y
 by wzajemne oddzia³ywanie pomiêdzy czê¶ciami sk³adowymi. Ka¿dy element 
s³ucha i tworzy zdarzenia dla których jest skonfigurowany .Generuje 
tak¿e swoje w³asne zdarzenia rozdzielaj±c je do poszczególnych 
zarejestrowanych s³uchaczy . To rozdzielanie</font><font color="#000000"> </font><font color="#000000" face="Times New Roman">jest
 kontrolowane poprzez system. Od tego czasu nie ma tam pojedynczych 
punktów uszkodzeñ. Dla unikniêcia utraty obiektów, które mog³y by byæ 
przyczyn± awarii aplikacji, system mo¿e byæ skonfigurowany na wielorakie
 sposoby w zale¿no¶ci od potrzeby. </font></p></li><font color="#000000" face="Times New Roman">
</font><font color="#000000"></font><li><font color="#000000"></font><p align="JUSTIFY"><font color="#000000">Platform independence</font><font face="Times New Roman">
 (niezale¿no¶æ platformy sprzêtu komputerowego) - komponenty serwerów 
mog± dzia³aæ na ró¿nych komputerach i platformach na których Java 
Virtual Machine i oprogramowanie Corby s± zaimplementowane. </font></p></li><font face="Times New Roman">
<li><p align="JUSTIFY">Locaion transparency (po³o¿enie przezroczysto¶ci)
 - obiekty mog± dorêczaæ zdarzenia do innych sk³adników bez wzglêdu na 
lokalizacje obiektu adresata. </p></li>
<li><p align="JUSTIFY">Browser-based user interface (osadzenie 
przegl±darki w interfejsie u¿ytkownika) - przegl±darka ¶wiatowej 
pajêczyny dostarcza zintegrowanej platformy dla czê¶ci obiektów klienta,
 które wymagaj± GUI. Równocze¶nie, przegl±darka i aplet INCA wymuszaj± 
na projektantach komponentów aby oni byli przywi±zani do rozwiniêtego 
modelu pajêczyny. </p></li>
</font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Administration
 - komponent narzêdzia konfiguracyjnego wykonuje w sposób ³atwy 
rekonfigurowanie po³±czeñ miêdzy wypadkowymi ¼ród³ami a swoimi 
budowanymi sk³adnikami . Jednak¿e, server to¿samo¶ci , który by³ u¿ywany
 jako lokalny serwer odbiornik, móg³by staæ siê powa¿nym 
administracyjnym wyj¶ciem</font><font color="#000000">. Z tuzinami lub </font><font color="#000000" face="Times New Roman">setkami serverów tego rodzaju , uruchamianie/zamykanie procedur bêdzie musia³o by¶ przeprowadzane z du¿± uwag±. </font></p></li><font color="#000000" face="Times New Roman">
</font><font face="Times New Roman"></font><li><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">Event
 (wypadkowy model) - u¿ywanie zdarzeñ do lu¼nego ³±czenia sk³adników 
serwerów zwykle okazywa³o siê byæ trafnym posuniêciem. My dokonali¶my 
odkrycia które, opisali¶my odno¶nie sposobu dzia³ania aplikacji. Obydwa 
elementy LongDistance i LDHandler mia³y za zadanie nawi±zaæ bezpo¶rednie
 po³±czenie do klienta servera w celu uaktualnienia bazy danych. 
Sk³adniki te pierwotnie funkcjonowa³y jako</font><font> </font><font face="Times New Roman">serwery bazodanowe maj±ce mo¿liwo¶æ uaktualnienia i poprawiania metod, które ³±cz± bezpo¶rednio pojedyncze lub grupy serwerów </font><font color="#000000" face="Times New Roman">.
 Kluczowym zamierzeniem tego problemu by³o stworzenie pracuj±cego 
przyk³adowego serwera bazodanowego oraz egzemplarza znaj±cego serwer, 
który potrzebuje odwo³ywaæ siê do jego metod. My rozwi±zali¶my to w 
naszym sposobie dzia³ania przez chwilowe przyjêcie odwo³ywania siê do 
serwera odbiorcy jako czê¶æ wynikowych danych. Ale kiedy liczba 
scenariuszy przyrostów, wyniki modelowania zwiêkszaj± zakres dzia³ania, 
staje siê to konieczne - jest to podstawa dotycz±ca systemowej 
skalowalno¶ci.</font></p></li></dir></ul><font color="#000000" face="Times New Roman">

</font><font color="#000000"><p align="JUSTIFY">&nbsp;</p></font><dir><font color="#000000">

</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">My
 eksperymentowali¶my z kilkoma przegl±darkami ¶wiatowej pajêczyny i 
znale¼li¶my powa¿ne usterki w tym jak one obs³uguj± strony internetowe i
 zarz±dzaj± apletami. Owe ¶rodki aplikacji nie mog³y wykonaæ zliczenia 
na przegl±darce utrzymywanych aktywnie ustawionych apletów ¿±danych dla 
sesji. Ró¿ne przegl±darki stron internetowych równie¿ stosuj± ró¿ne 
zabezpieczenie. Wspieraj± one równie¿ ma³o konsekwent</font><font>nie aplety Javy.</font></p><font>
</font><font face="Times New Roman"></font><p align="JUSTIFY"><font face="Times New Roman">W
 tej implementacji u¿ywali¶my tylko HotJavy . Za³o¿yli¶my, ¿e 
implementacja Javy RMI bêdzie prostsza od Corby z dwóch zasadniczych 
powodów. Pierwszym, naszym jêzykiem implementacyjnym jest Java i model 
zdalnego obiektu Javy jest naturalnym rozwiniêciem lokalnego obiektu 
modelu; model - jêzykowo niezale¿nego obiektu Corby, jednak musi byæ 
odwzorowany w Javie. Na przyk³ad, w implementacji Javy RMI, je¿eli 
klient zawiera odwo³anie do zdalnego obiektu Javy, który jest bardziej 
charakterystyczn</font><font>y</font><font face="Times New Roman">m 
typem, proste opuszczenie wystarcza aby traktowaæ obiekt referencyjny 
jako odwo³anie do bardziej specyficznego typu. W implementacji Corby, 
je¿eli klient zawiera odwo³anie do obiektu Corby odwo³ywanego, który 
jest bardziej specyficznym typem, opuszczony</font><font> </font><font face="Times New Roman">nie
 bêdzie pracowa³. W³a¶ciwie w kodzie klienta, my u¿ywali¶my rozkazu 
"narrow" w stosownej klasie Helper do wykonania rzutowania bardziej 
charakterystycznych przyk³adów odwo³añ Corby. </font></p><font face="Times New Roman">
</font><font <p="" align="JUSTIFY">	Wszelkie prowadzone prace w kierunku badania architektury oprogramowa</font><font nia="" za="" podstawê="" przyjmuj±="" prowadzenie="" do¶wiadczeñ="" na="" sk³adnikach="" ugruntowanych="" w="" architekturach,="" które="" podtrzymuj±="" wielokrotne="" po³±czenia="" i="" wspó³dzia³aj±="" technologicznie.="" my="" tutaj="" szczególnie="" zainteresowali¶my="" siê="" przysz³ymi="" implementacjami="" inca,="" u¿ywanie<="" font="" face="Times New Roman"><font>m</font><font face="Times New Roman">
 DCOM i Enterprise JavaBeans. Ciekaw± spraw± je¿eli chodzi o ten obszar 
zainteresowañ by³o by zbadanie wymagañ pod wzglêdem konfigurowalo¶ci, 
administracji i monitoringu. <p></p></font></font></dir><font nia="" za="" podstawê="" przyjmuj±="" prowadzenie="" do¶wiadczeñ="" na="" sk³adnikach="" ugruntowanych="" w="" architekturach,="" które="" podtrzymuj±="" wielokrotne="" po³±czenia="" i="" wspó³dzia³aj±="" technologicznie.="" my="" tutaj="" szczególnie="" zainteresowali¶my="" siê="" przysz³ymi="" implementacjami="" inca,="" u¿ywanie<="" font="" face="Times New Roman"><font face="Times New Roman">

</font><b><font face="Arial"><p>10. Literatura</p>

</font></b>


<dir><font size="2">
</font><ol><font size="2">
<br>
<li>Israel Ben-Shaul, James W. Gish, William Robinson, <i>An Integrated Network Component Architecture</i> ,Columbia 1998 </li>
<li>www.cis.com.pl</li>
</font><font size="2"><li>www.agh.pl/corba</li></font></ol><font size="2">

</font></dir>


<p align="JUSTIFY">&nbsp;</p>
</font><font color="#000000"><p align="JUSTIFY">&nbsp;</p>
<p align="JUSTIFY">&nbsp;</p>
</font><font><p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</font>

</font></font></font></font></font></body></html>